[
    {
        "documentation_url": "https://developer.github.com/v3/repos/contents/",
        "message": "No commit found for the ref 9a3db3eedeebdccce799963cfc2cc7eb656202b7"
    },
    {
        "documentation_url": "https://developer.github.com/v3/repos/contents/#get-contents",
        "message": "This repository is empty."
    },
    {
        "DownloadLocation": "https://api.github.com/repos/marcobubke/localfortuneclient/zipball/342953a5ee82e0e177cd53cffdb5882fd44192a3",
        "Icon": "core.png",
        "Id": 2,
        "LongDescription": "",
        "Name": "Local Fortune Client Example",
        "ProjectFile": "localfortuneclient.pro",
        "ShortDescription": "The Local Fortune Client example shows how to create a client for a simple local service using QLocalSocket.",
        "Tags": "core local socket advanced"
    },
    {
        "DownloadLocation": "https://api.github.com/repos/marcobubke/localfortuneserver/zipball/87fb34a9c690cbf0050c4b14df73133af4fcb446",
        "Icon": "core.png",
        "Id": 3,
        "LongDescription": "The Local Fortune Server example shows how to create a server for a simple local service. It is intended to be run alongside the Local Fortune Client Example.",
        "Name": "Local Fortune Server",
        "ProjectFile": "localfortuneserver.pro",
        "ShortDescription": "Demonstrates using QLocalServer and QLocalSocket for serving a simple local service.",
        "Tags": "core server local socket advanced"
    },
    {
        "DownloadLocation": "https://api.github.com/repos/marcobubke/queuedcustomtype/zipball/02639caad6b09e412a7dfc41e6c1768383359e56",
        "Icon": "core.png",
        "Id": 4,
        "LongDescription": "<p>In the Custom Type Example, we showed how to integrate custom types with the meta-object system, enabling them to be stored in QVariant objects, written out in debugging information and used in signal-slot communication. In this example, we create a new value class, Block, and register it with the meta-object system to enable us to send instances of it between threads using queued signals and slots.</p>",
        "Name": "Queued Custom Type",
        "ProjectFile": "queuedcustomtype.pro",
        "ShortDescription": "The Queued Custom Type example shows how to send custom types between threads with queued signals and slots.",
        "Tags": "core signal slot thread advanced"
    },
    {
        "DownloadLocation": "https://api.github.com/repos/marcobubke/semaphores/zipball/6bbc86a8d3eb5da44bf0d7524814f438b64d8875",
        "Icon": "core.png",
        "Id": 5,
        "LongDescription": "<p>The producer writes data to the buffer until it reaches the end of the buffer, at which point it restarts from the beginning, overwriting existing data. The consumer thread reads the data as it is produced and writes it to standard error.</p><p>Semaphores make it possible to have a higher level of concurrency than mutexes. If accesses to the buffer were guarded by a QMutex, the consumer thread couldn't access the buffer at the same time as the producer thread. Yet, there is no harm in having both threads working on different parts of the buffer at the same time.</p><p>The example comprises two classes: Producer and Consumer. Both inherit from QThread. The circular buffer used for communicating between these two classes and the semaphores that protect it are global variables.</p><p>An alternative to using QSemaphore to solve the producer-consumer problem is to use QWaitCondition and QMutex. This is what the Wait Conditions Example does.</p>",
        "Name": "Semaphores",
        "ProjectFile": "semaphores.pro",
        "ShortDescription": "The Semaphores example shows how to use QSemaphore to control access to a circular buffer shared by a producer thread and a consumer thread.",
        "Tags": "core thread semaphore advanced"
    },
    {
        "DownloadLocation": "https://api.github.com/repos/marcobubke/sharedmemory/zipball/60f574bae140d81be232eacbafdd4a5aa9b7a41f",
        "Icon": "core.png",
        "Id": 1,
        "LongDescription": "<p>It is a simple dialog that presents a few buttons. To compile the example, run make in qt/examples/ipc. Then run the executable twice to create two processes running the dialog. In one of the processes, press the button to load an image into a shared memory segment, and then select an image file to load. Once the first process has loaded and displayed the image, in the second process, press the button to read the same image from shared memory. The second process displays the same image loaded from its new loaction in shared memory.</p><p>The class contains a data member QSharedMemory::sharedMemory, which is initialized with the key 'QSharedMemoryExample' to force all instances of Dialog to access the same shared memory segment. The constructor also connects the clicked() signal from each of the three dialog buttons to the slot function appropriate for handling each button.</p>",
        "Name": "Shared Memory",
        "ProjectFile": "sharedmemory.pro",
        "ShortDescription": "This class is a simple example of how to use QSharedMemory.",
        "Tags": "core shared memory advanced"
    },
    {
        "DownloadLocation": "https://api.github.com/repos/marcobubke/waitconditions/zipball/9a364786aacdfaee0b00a9b897a8f87f41b6fd66",
        "Icon": "core.png",
        "Id": 6,
        "LongDescription": "<p>The producer writes data to the buffer until it reaches the end of the buffer, at which point it restarts from the beginning, overwriting existing data. The consumer thread reads the data as it is produced and writes it to standard error.</p><p>Wait conditions make it possible to have a higher level of concurrency than what is possible with mutexes alone. If accesses to the buffer were simply guarded by a QMutex, the consumer thread couldn't access the buffer at the same time as the producer thread. Yet, there is no harm in having both threads working on different parts of the buffer at the same time.</p><p>The example comprises two classes: Producer and Consumer. Both inherit from QThread. The circular buffer used for communicating between these two classes and the synchronization tools that protect it are global variables.</p><p>An alternative to using QWaitCondition and QMutex to solve the producer-consumer problem is to use QSemaphore. This is what the Semaphores Example does.</p>",
        "Name": "Wait Conditions",
        "ProjectFile": "waitconditions.pro",
        "ShortDescription": "The Wait Conditions example shows how to use QWaitCondition and QMutex to control access to a circular buffer shared by a producer thread and a consumer thread.",
        "Tags": "core wait condition thread advanced"
    }
]
